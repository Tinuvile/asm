# 汇编语言课程项目开发文档

**项目名称**：基于 x86-64 Linux 的简易内存分配器设计与实现

**学生姓名**：张竹和

**学生学号**：2352495

**提交日期**：2025年12月24日

---

## 1. 项目概述

### 1.1 项目背景

动态内存管理是计算机系统中的核心机制之一。在高级语言（如 C/C++）中，程序员习惯使用 `malloc` 和 `free` 进行内存资源的申请与释放，往往忽略了底层的实现细节。为了深入理解操作系统内存模型、系统调用接口（System Call Interface）以及汇编语言对硬件资源的直接控制能力，本项目旨在 x86-64 Linux 环境下，使用 NASM 汇编语言手写实现一个具备工业级雏形的内存分配器。

### 1.2 项目目标

本项目旨在实现一个轻量级、高效的内存分配器，具体目标包括：

* 实现基于 **显式空闲链表 (Explicit Free List)** 的堆内存管理。
* 支持 **首次适应算法 (First Fit)** 进行内存分配。
* 实现 **内存对齐 (Memory Alignment)** 以满足 x64 架构的访问效率要求。
* 支持 **内存合并 (Coalescing)** 机制，解决内存碎片化问题。
* 不依赖 C 标准库（glibc），直接通过 Linux 系统调用（`sys_brk`）与内核交互。

---

## 2. 系统设计与原理

本项目的核心设计基于侵入式链表结构，将管理信息直接嵌入到堆内存中。

### 2.1 内存块物理结构设计

为了管理每一个内存块，我设计了大小为 16 字节的头部（Header）。Header 紧邻用户数据区（User Data）之前。

![内存块物理结构](image/openai/Memory%20Block%20Layout.png)
*<center>图 1：内存块物理结构设计 (Memory Block Layout)</center>*

如**图 1** 所示，Header 包含两个 64 位字段：

1. **Size & Flag (Offset 0)**: 存储该内存块的大小。由于实现了 16 字节对齐，大小数值的最低 4 位始终为 0。利用这一特性，将最低位（Bit 0）作为 **分配标记 (Allocation Flag)**：`1` 表示已占用，`0` 表示空闲。
2. **Next Pointer (Offset 8)**: 存储指向下一个内存块 Header 的物理地址。

### 2.2 堆链表组织架构

整个堆空间被组织成一个单向链表。全局变量 `heap_start` 指向链表的第一个块。

![堆链表结构](image/openai/Heap%20Linked%20List%20Structure.png)
*<center>图 2：堆链表组织架构 (Heap Linked List Structure)</center>*

如**图 2** 所示，系统中的内存块通过 `Next Pointer` 依次连接。内存分配器通过遍历该链表来寻找空闲资源或挂载新申请的内存区域。这种设计使得内存管理具有极高的灵活性，且元数据开销固定。

---

## 3. 核心功能实现

### 3.1 内存分配算法 (`my_malloc`)

内存分配采用 **首次适应算法 (First Fit)**，该策略在遍历链表时，一旦发现满足大小要求的空闲块即刻分配，具有较高的执行效率。

![算法流程图](image/openai/Algorithm%20Flowchart.png)
*<center>图 3：内存分配算法流程图 (Algorithm Flowchart)</center>*

结合**图 3** 与汇编代码，具体流程如下：

1. **对齐与计算**：将用户请求的大小向上取整为 16 的倍数，并加上 16 字节 Header 开销。
2. **链表遍历**：从 `heap_start` 开始扫描堆链表。
3. **查找可用块**：检查每个块的 Header，若 `Flag == 0` (空闲) 且 `Size >= Request`，则标记该块为占用并返回 User Data 指针。
4. **堆扩展 (Heap Extension)**：若遍历结束仍未找到合适块，调用 Linux 系统调用 `sys_brk` (Syscall 12) 获取当前堆顶（Program Break），计算新地址后再次调用 `sys_brk` 扩展堆空间，并在新空间初始化 Header，挂载到链表末尾。

### 3.2 内存释放与合并机制 (`my_free`)

单纯的内存释放会导致严重的外部碎片问题。本项目实现了**向后合并 (Forward Coalescing)** 策略。

![内存合并原理](image/openai/Coalescing%20Mechanism.png)
*<center>图 4：内存合并原理示意图 (Coalescing Mechanism)</center>*

如**图 4** 所示，当释放一个内存块（Block A）时，分配器不仅将其标记为空闲，还会检查其物理相邻的下一个块（Block B）：

1. **检查**：读取 `Block A -> Next` 找到 Block B，检查 Block B 的 Flag 是否为空闲。
2. **合并**：若 B 也是空闲的，将 B 的大小加到 A 上 (`A.Size += B.Size`)，并将 A 的 Next 指针指向 B 的下一个块 (`A.Next = B.Next`)。
3. **迭代**：重复上述过程，直到无法合并为止。
   此机制有效地将零散的小内存块融合成大块，显著提升了内存复用率。

---

## 4. 项目开发流程

本项目的开发经历了四个主要阶段：

1. **基础调研与设计阶段**：
   * 查阅 Linux x64 System Call Table，理解 `sys_brk` 的工作原理。
   * 设计内存对齐方案，确定 16 字节 Header 的位操作逻辑。
2. **核心分配功能开发**：
   * 编写 `my_malloc`，实现链表遍历和堆扩展逻辑。
   * 实现辅助函数 `print_hex` 和 `print_str`，用于在无标准库环境下进行调试输出。
3. **释放与优化阶段**：
   * 实现 `my_free` 的基础标记清除功能。
   * 在 `my_free` 中加入 Coalescing 循环逻辑，解决内存碎片问题。编写了专门的测试用例（Test Case 5）验证合并逻辑的正确性（即验证释放后的地址复用）。
4. **测试与验证阶段**：
   * 编写多组测试用例，覆盖：常规分配、数据写入、内存释放、释放后复用、合并后分配大内存块等场景。
   * 使用 GDB 进行指令级调试，确保寄存器状态和栈平衡。

---

## 5. 心得与体会

本次基于汇编语言的系统级编程实践，带给我深刻的技术提升与思考：

1. **从抽象到具象的跨越**：在高级语言中，指针只是一个抽象类型；而在汇编中，我必须手动通过 `add`、`sub` 指令控制指针在 Header 和 User Data 之间跳转。这种“手动挡”驾驶的体验让我对内存地址有了具象的认知。
2. **对“栈平衡”的敬畏**：开发初期曾因 `push`/`pop` 不配对导致函数返回地址错误，引发 Segmentation Fault。这让我深刻理解了调用约定（Calling Convention）的重要性，养成了严谨的寄存器保护习惯。
3. **位操作的工程美学**：利用内存对齐留下的低 4 位空间存储状态标记（Flag），是一种很有趣的压缩技巧。在汇编中通过 `and`、`or` 指令操作单个比特位，让我感受到了底层编程的精简与高效。
4. **操作系统原理的实践**：通过直接操作 `brk` 指针管理堆，我打破了对 `malloc` 的“黑盒”认知，真正触碰到了用户空间与内核空间的边界。

本项目是一个基础功能完备的内存分配器，也是我的一次对计算机系统底层原理的深度探索。